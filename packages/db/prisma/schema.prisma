generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Phase 1: User de base avec économie simple
model User {
  id              String   @id @default(cuid())
  discordId       String   @unique
  discordUsername String
  discordAvatar   String?

  balance        Decimal @default(0) @db.Decimal(10, 2)
  clicksToday    Int     @default(0)
  lastClickReset DateTime @default(now())
  clickerIcon    String  @default("cookie") // "cookie", "cookie-bw", "cookie-cute"

  // Voice tracking
  dailyVoiceMinutes  Int      @default(0)      // Minutes cumulées aujourd'hui
  lastVoiceReset     DateTime @default(now())  // Dernier reset journalier
  voiceStreak        Int      @default(0)      // Jours consécutifs avec 30+ min de vocal
  totalVoiceMinutes  Int      @default(0)      // Total all-time pour stats

  isAdmin  Boolean @default(false)
  isBanned Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transactions Transaction[]
  upgrades     UserUpgrade[]
  
  // Casino
  crashBets       CrashBet[]
  diceGamesAsP1   DiceGame[]  @relation("DicePlayer1")
  diceGamesAsP2   DiceGame[]  @relation("DicePlayer2")
  pfcGamesAsP1    PFCGame[]   @relation("PFCPlayer1")
  pfcGamesAsP2    PFCGame[]   @relation("PFCPlayer2")
  lotteryTickets  LotteryTicket[]
  
  // Game Rooms
  hostedRooms     GameRoom[]  @relation("RoomHost")
}

// Historique des transactions
model Transaction {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        String   // "click", "passive", "vocal", "shop", etc.
  amount      Decimal  @db.Decimal(10, 2)
  description String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
}

// Config globale du jeu
model GameConfig {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt
}

// Sessions vocales actives (mis à jour par le bot)
model VoiceSession {
  discordId    String   @id
  channelId    String
  channelName  String?
  guildId      String
  othersCount  Int      @default(0)
  joinedAt     DateTime @default(now())
  lastUpdate   DateTime @default(now())
}

// Phase 2: Upgrades achetés par les users
model UserUpgrade {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  upgradeId String   // ex: "souris_gaming", "clavier_meca", etc.
  level     Int      @default(1) // 1-3 (stackable x3)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, upgradeId])
  @@index([userId])
}

// ============================================
// PHASE 2: CASINO
// ============================================

// Crash Game - une partie avec multiplicateur
model CrashGame {
  id           String   @id @default(cuid())
  crashPoint   Decimal  @db.Decimal(10, 4) // Le multiplicateur où ça crash
  status       String   @default("waiting") // "waiting", "running", "crashed"
  startedAt    DateTime?
  crashedAt    DateTime?
  createdAt    DateTime @default(now())

  bets CrashBet[]

  @@index([status])
  @@index([createdAt])
}

// Paris sur un crash game
model CrashBet {
  id          String   @id @default(cuid())
  crashGameId String
  crashGame   CrashGame @relation(fields: [crashGameId], references: [id], onDelete: Cascade)
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  amount      Decimal  @db.Decimal(10, 2) // Mise
  cashOutAt   Decimal? @db.Decimal(10, 4) // Multiplicateur de cashout (null si pas cashout)
  profit      Decimal? @db.Decimal(10, 2) // Gain net (positif ou négatif)
  
  createdAt   DateTime @default(now())

  @@index([crashGameId])
  @@index([userId])
}

// Duel de Dés (legacy 1v1)
model DiceGame {
  id           String   @id @default(cuid())
  
  player1Id    String   // Celui qui lance le défi
  player1      User     @relation("DicePlayer1", fields: [player1Id], references: [id], onDelete: Cascade)
  player2Id    String?  // Celui qui accepte (null = en attente)
  player2      User?    @relation("DicePlayer2", fields: [player2Id], references: [id], onDelete: Cascade)
  
  amount       Decimal  @db.Decimal(10, 2) // Mise de chaque joueur
  
  player1Roll  Int?     // Résultat dés joueur 1 (2d6)
  player2Roll  Int?     // Résultat dés joueur 2
  winnerId     String?  // ID du gagnant (null si égalité)
  
  status       String   @default("pending") // "pending", "accepted", "completed", "cancelled", "expired"
  
  // Rematch votes
  player1WantsRematch Boolean @default(false)
  player2WantsRematch Boolean @default(false)
  
  expiresAt    DateTime // Expire après 5 min si pas accepté
  createdAt    DateTime @default(now())
  completedAt  DateTime?

  @@index([player1Id])
  @@index([player2Id])
  @@index([status])
}

// ============================================
// GAME ROOMS - Système multijoueur unifié
// ============================================

// Room de jeu (dés, pfc, etc.)
model GameRoom {
  id           String   @id @default(cuid())
  
  gameType     String   // "dice", "pfc"
  amount       Decimal  @db.Decimal(10, 2) // Mise par joueur
  
  minPlayers   Int      @default(2)  // Minimum pour lancer
  maxPlayers   Int      @default(8)  // Maximum dans la room
  
  code         String?  @unique // Code pour room privée (null = publique)
  
  hostId       String   // Créateur de la room
  host         User     @relation("RoomHost", fields: [hostId], references: [id], onDelete: Cascade)
  
  status       String   @default("waiting") // "waiting", "countdown", "playing", "finished"
  
  countdownEnd DateTime? // Fin du countdown (15s après minPlayers atteint)
  startedAt    DateTime?
  finishedAt   DateTime?
  
  createdAt    DateTime @default(now())
  expiresAt    DateTime // Auto-delete si vide après 5min
  
  players      GameRoomPlayer[]
  
  @@index([status])
  @@index([gameType, status])
  @@index([code])
}

// Joueur dans une room
model GameRoomPlayer {
  id           String   @id @default(cuid())
  
  roomId       String
  room         GameRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  userId       String   
  username     String   // Username pour affichage rapide
  
  isReady      Boolean  @default(false) // A confirmé sa participation
  
  // Résultats (remplis quand la partie est jouée)
  roll         Int?     // Pour dice: total des dés
  dice1        Int?     // Dé 1
  dice2        Int?     // Dé 2
  choice       String?  // Pour pfc: "pierre", "feuille", "ciseaux"
  
  profit       Decimal? @db.Decimal(10, 2) // Gain/perte
  rank         Int?     // Classement final
  
  joinedAt     DateTime @default(now())
  
  @@unique([roomId, userId])
  @@index([roomId])
  @@index([userId])
}

// Pierre-Feuille-Ciseaux
model PFCGame {
  id           String   @id @default(cuid())
  
  player1Id    String
  player1      User     @relation("PFCPlayer1", fields: [player1Id], references: [id], onDelete: Cascade)
  player2Id    String?
  player2      User?    @relation("PFCPlayer2", fields: [player2Id], references: [id], onDelete: Cascade)
  
  amount       Decimal  @db.Decimal(10, 2)
  
  player1Choice String?  // "pierre", "feuille", "ciseaux"
  player2Choice String?
  winnerId      String?  // null si égalité
  
  status       String   @default("pending") // "pending", "accepted", "playing", "completed", "cancelled", "expired"
  
  // Rematch votes
  player1WantsRematch Boolean @default(false)
  player2WantsRematch Boolean @default(false)
  
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  completedAt  DateTime?

  @@index([player1Id])
  @@index([player2Id])
  @@index([status])
}

// Loterie hebdomadaire
model Lottery {
  id          String   @id @default(cuid())
  
  jackpot     Decimal  @db.Decimal(10, 2) @default(20) // Commence à 20€
  winnerId    String?  // ID du gagnant
  winnerPrize Decimal? @db.Decimal(10, 2)
  
  status      String   @default("open") // "open", "drawing", "completed"
  
  drawAt      DateTime // Date du tirage
  createdAt   DateTime @default(now())
  completedAt DateTime?

  tickets LotteryTicket[]

  @@index([status])
  @@index([drawAt])
}

// Tickets de loterie
model LotteryTicket {
  id        String   @id @default(cuid())
  lotteryId String
  lottery   Lottery  @relation(fields: [lotteryId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())

  @@index([lotteryId])
  @@index([userId])
}
