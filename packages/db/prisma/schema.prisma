generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Phase 1: User de base avec économie simple
model User {
  id              String   @id @default(cuid())
  discordId       String   @unique
  discordUsername String
  discordAvatar   String?

  balance        Decimal @default(0) @db.Decimal(10, 2)
  dahkaCoins     Decimal @default(0) @db.Decimal(10, 4) // DahkaCoin balance
  dcAvgBuyPrice  Decimal? @db.Decimal(10, 4)            // Prix moyen d'achat (null si jamais investi)
  
  clicksToday    Int     @default(0)
  lastClickReset DateTime @default(now())
  clickerIcon    String  @default("cookie") // "cookie", "cookie-bw", "cookie-cute"

  // Voice tracking
  dailyVoiceMinutes  Int      @default(0)      // Minutes cumulées aujourd'hui
  lastVoiceReset     DateTime @default(now())  // Dernier reset journalier
  voiceStreak        Int      @default(0)      // Jours consécutifs avec 30+ min de vocal
  totalVoiceMinutes  Int      @default(0)      // Total all-time pour stats

  // Robbery cooldown
  lastRobberyAt    DateTime?  // Dernière tentative de braquage

  isAdmin  Boolean @default(false)
  isBanned Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transactions Transaction[]
  upgrades     UserUpgrade[]
  
  // Casino
  crashBets       CrashBet[]
  diceGamesAsP1   DiceGame[]  @relation("DicePlayer1")
  diceGamesAsP2   DiceGame[]  @relation("DicePlayer2")
  pfcGamesAsP1    PFCGame[]   @relation("PFCPlayer1")
  pfcGamesAsP2    PFCGame[]   @relation("PFCPlayer2")
  lotteryTickets  LotteryTicket[]
  
  // Game Rooms
  hostedRooms     GameRoom[]  @relation("RoomHost")
}

// Historique des transactions
model Transaction {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        String   // "click", "passive", "vocal", "shop", etc.
  amount      Decimal  @db.Decimal(10, 2)
  description String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
}

// Config globale du jeu
model GameConfig {
  key       String   @id
  value     Json
  updatedAt DateTime @updatedAt
}

// Sessions vocales actives (mis à jour par le bot)
model VoiceSession {
  discordId    String   @id
  channelId    String
  channelName  String?
  guildId      String
  othersCount  Int      @default(0)
  joinedAt     DateTime @default(now())
  lastUpdate   DateTime @default(now())
}

// Phase 2: Upgrades achetés par les users
model UserUpgrade {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  upgradeId String   // ex: "souris_gaming", "clavier_meca", etc.
  level     Int      @default(1) // 1-3 (stackable x3)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, upgradeId])
  @@index([userId])
}

// ============================================
// PHASE 2: CASINO
// ============================================

// Crash Game - une partie avec multiplicateur
model CrashGame {
  id           String   @id @default(cuid())
  crashPoint   Decimal  @db.Decimal(10, 4) // Le multiplicateur où ça crash
  status       String   @default("waiting") // "waiting", "running", "crashed"
  startedAt    DateTime?
  crashedAt    DateTime?
  createdAt    DateTime @default(now())

  bets CrashBet[]

  @@index([status])
  @@index([createdAt])
}

// Paris sur un crash game
model CrashBet {
  id          String   @id @default(cuid())
  crashGameId String
  crashGame   CrashGame @relation(fields: [crashGameId], references: [id], onDelete: Cascade)
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  amount      Decimal  @db.Decimal(10, 2) // Mise
  cashOutAt   Decimal? @db.Decimal(10, 4) // Multiplicateur de cashout (null si pas cashout)
  profit      Decimal? @db.Decimal(10, 2) // Gain net (positif ou négatif)
  wantsSkip   Boolean  @default(false) // Vote pour skip le countdown
  
  createdAt   DateTime @default(now())

  @@index([crashGameId])
  @@index([userId])
}

// Duel de Dés (legacy 1v1)
model DiceGame {
  id           String   @id @default(cuid())
  
  player1Id    String   // Celui qui lance le défi
  player1      User     @relation("DicePlayer1", fields: [player1Id], references: [id], onDelete: Cascade)
  player2Id    String?  // Celui qui accepte (null = en attente)
  player2      User?    @relation("DicePlayer2", fields: [player2Id], references: [id], onDelete: Cascade)
  
  amount       Decimal  @db.Decimal(10, 2) // Mise de chaque joueur
  
  player1Roll  Int?     // Résultat dés joueur 1 (2d6)
  player2Roll  Int?     // Résultat dés joueur 2
  winnerId     String?  // ID du gagnant (null si égalité)
  
  status       String   @default("pending") // "pending", "accepted", "completed", "cancelled", "expired"
  
  // Rematch votes
  player1WantsRematch Boolean @default(false)
  player2WantsRematch Boolean @default(false)
  
  expiresAt    DateTime // Expire après 5 min si pas accepté
  createdAt    DateTime @default(now())
  completedAt  DateTime?

  @@index([player1Id])
  @@index([player2Id])
  @@index([status])
}

// ============================================
// GAME ROOMS - Système multijoueur unifié
// ============================================

// Room de jeu (dés, pfc, etc.)
model GameRoom {
  id           String   @id @default(cuid())
  
  gameType     String   // "dice", "pfc"
  amount       Decimal  @db.Decimal(10, 2) // Mise par joueur
  
  minPlayers   Int      @default(2)  // Minimum pour lancer
  maxPlayers   Int      @default(8)  // Maximum dans la room
  
  code         String?  @unique // Code pour room privée (null = publique)
  
  hostId       String   // Créateur de la room
  host         User     @relation("RoomHost", fields: [hostId], references: [id], onDelete: Cascade)
  
  status       String   @default("waiting") // "waiting", "countdown", "playing", "finished"
  
  countdownEnd DateTime? // Fin du countdown (15s après minPlayers atteint)
  startedAt    DateTime?
  finishedAt   DateTime?
  
  createdAt    DateTime @default(now())
  expiresAt    DateTime // Auto-delete si vide après 5min
  
  players      GameRoomPlayer[]
  
  @@index([status])
  @@index([gameType, status])
  @@index([code])
}

// Joueur dans une room
model GameRoomPlayer {
  id           String   @id @default(cuid())
  
  roomId       String
  room         GameRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  userId       String   
  username     String   // Username pour affichage rapide
  
  isReady      Boolean  @default(false) // A confirmé sa participation
  
  // Résultats (remplis quand la partie est jouée)
  roll         Int?     // Pour dice: total des dés
  dice1        Int?     // Dé 1
  dice2        Int?     // Dé 2
  choice       String?  // Pour pfc: "pierre", "feuille", "ciseaux"
  
  profit       Decimal? @db.Decimal(10, 2) // Gain/perte
  rank         Int?     // Classement final
  
  joinedAt     DateTime @default(now())
  
  @@unique([roomId, userId])
  @@index([roomId])
  @@index([userId])
}

// Pierre-Feuille-Ciseaux
model PFCGame {
  id           String   @id @default(cuid())
  
  player1Id    String
  player1      User     @relation("PFCPlayer1", fields: [player1Id], references: [id], onDelete: Cascade)
  player2Id    String?
  player2      User?    @relation("PFCPlayer2", fields: [player2Id], references: [id], onDelete: Cascade)
  
  amount       Decimal  @db.Decimal(10, 2)
  
  player1Choice String?  // "pierre", "feuille", "ciseaux"
  player2Choice String?
  winnerId      String?  // null si égalité
  
  status       String   @default("pending") // "pending", "accepted", "playing", "completed", "cancelled", "expired"
  
  // Rematch votes
  player1WantsRematch Boolean @default(false)
  player2WantsRematch Boolean @default(false)
  
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  completedAt  DateTime?

  @@index([player1Id])
  @@index([player2Id])
  @@index([status])
}

// Loterie hebdomadaire
model Lottery {
  id          String   @id @default(cuid())
  
  jackpot     Decimal  @db.Decimal(10, 2) @default(20) // Commence à 20€
  winnerId    String?  // ID du gagnant
  winnerPrize Decimal? @db.Decimal(10, 2)
  
  status      String   @default("open") // "open", "drawing", "completed"
  
  drawAt      DateTime // Date du tirage
  createdAt   DateTime @default(now())
  completedAt DateTime?

  tickets LotteryTicket[]

  @@index([status])
  @@index([drawAt])
}

// Tickets de loterie
model LotteryTicket {
  id        String   @id @default(cuid())
  lotteryId String
  lottery   Lottery  @relation(fields: [lotteryId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())

  @@index([lotteryId])
  @@index([userId])
}

// ============================================
// PHASE 3: BRAQUAGES & BOUNTIES
// ============================================

// Historique des braquages
model Robbery {
  id          String   @id @default(cuid())
  
  robberId    String   // Celui qui braque
  victimId    String   // Celui qui se fait braquer
  
  success     Boolean  // Réussi ou échoué
  amount      Decimal  @db.Decimal(10, 2) // Montant volé (ou perdu si échec)
  
  // Stats pour analytics
  robberBalance  Decimal @db.Decimal(10, 2) // Balance du braqueur avant
  victimBalance  Decimal @db.Decimal(10, 2) // Balance de la victime avant
  rollChance     Int     // Chance de réussite (0-100)
  rollResult     Int     // Résultat du dé (0-100)
  
  createdAt   DateTime @default(now())

  @@index([robberId])
  @@index([victimId])
  @@index([createdAt])
}

// Bounties (primes sur la tête de quelqu'un)
model Bounty {
  id          String   @id @default(cuid())
  
  posterId    String   // Celui qui met la prime
  targetId    String   // La cible
  claimerId   String?  // Celui qui a claim la prime (null si pas encore)
  
  amount      Decimal  @db.Decimal(10, 2) // Montant de la prime
  
  status      String   @default("active") // "active", "claimed", "expired", "cancelled"
  
  expiresAt   DateTime // Expire après 48h
  createdAt   DateTime @default(now())
  claimedAt   DateTime?

  @@index([targetId, status])
  @@index([posterId])
  @@index([status])
  @@index([expiresAt])
}

// ============================================
// PHASE 4: VOTES & JUSTICE
// ============================================

// Warn/Vote pour amendes
model WarnVote {
  id           String   @id @default(cuid())
  
  accuserId    String   // Celui qui lance le warn
  accusedId    String   // L'accuse
  
  reason       String   // Raison du warn
  amount       Decimal  @db.Decimal(10, 2) // Montant de l'amende demandee
  
  status       String   @default("voting") // "voting", "guilty", "innocent", "expired"
  
  // Resultats
  guiltyVotes    Int     @default(0)
  innocentVotes  Int     @default(0)
  
  endsAt       DateTime // Fin du vote (10 min)
  createdAt    DateTime @default(now())
  resolvedAt   DateTime?

  votes WarnBallot[]

  @@index([accuserId])
  @@index([accusedId])
  @@index([status])
  @@index([endsAt])
}

// Bulletins de vote pour les warns
model WarnBallot {
  id         String   @id @default(cuid())
  
  warnVoteId String
  warnVote   WarnVote @relation(fields: [warnVoteId], references: [id], onDelete: Cascade)
  
  odrzerId   String   // Celui qui vote
  vote       String   // "guilty" ou "innocent"
  
  createdAt  DateTime @default(now())

  @@unique([warnVoteId, odrzerId])
  @@index([warnVoteId])
  @@index([odrzerId])
}

// Revolution / Coup d'etat
model Revolution {
  id           String   @id @default(cuid())
  
  initatorId   String   // Celui qui lance la revolution
  targetId     String   // Le plus riche (cible)
  
  status       String   @default("voting") // "voting", "success", "failed", "expired"
  
  forVotes     Int      @default(0)
  againstVotes Int      @default(0)
  
  targetBalance   Decimal @db.Decimal(10, 2) // Balance de la cible au moment du lancement
  medianBalance   Decimal @db.Decimal(10, 2) // Mediane au moment du lancement
  
  endsAt       DateTime // Fin du vote (30 min)
  createdAt    DateTime @default(now())
  resolvedAt   DateTime?

  votes RevolutionBallot[]

  @@index([status])
  @@index([endsAt])
}

// Bulletins de vote pour les revolutions
model RevolutionBallot {
  id            String     @id @default(cuid())
  
  revolutionId  String
  revolution    Revolution @relation(fields: [revolutionId], references: [id], onDelete: Cascade)
  
  odrzerId      String     // Celui qui vote
  vote          String     // "for" ou "against"
  
  createdAt     DateTime   @default(now())

  @@unique([revolutionId, odrzerId])
  @@index([revolutionId])
  @@index([odrzerId])
}

// ============================================
// INVENTAIRE - Items consommables
// ============================================

model InventoryItem {
  id          String   @id @default(cuid())
  
  userId      String
  itemId      String   // ID de l'item (pied_de_biche, gilet_pare_balles, etc.)
  
  charges     Int      // Utilisations restantes (-1 = permanent)
  expiresAt   DateTime? // Pour les items temporaires (VPN, etc.)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([userId, itemId])
}

// ============================================
// CLICK BATTLE - Duel de clics
// ============================================

model ClickBattle {
  id           String   @id @default(cuid())
  
  player1Id    String   // Celui qui lance le défi
  player2Id    String?  // Celui qui accepte
  
  amount       Decimal  @db.Decimal(10, 2) // Mise de chaque joueur
  duration     Int      @default(10) // Durée en secondes (10s par défaut)
  
  // Résultats (soumis à la fin)
  player1Clicks  Int?
  player2Clicks  Int?
  winnerId       String?  // null si égalité
  
  status       String   @default("pending") // "pending", "accepted", "playing", "revealing", "completed", "cancelled", "expired"
  
  // Timestamps
  acceptedAt   DateTime?
  startedAt    DateTime? // Quand les deux joueurs ont confirmé être prêts
  revealedAt   DateTime? // Quand les résultats sont révélés
  
  expiresAt    DateTime // Expire après 5 min si pas accepté
  createdAt    DateTime @default(now())
  completedAt  DateTime?

  @@index([player1Id])
  @@index([player2Id])
  @@index([status])
}

// ============================================
// PHASE 5: DAHKACOIN (Crypto Fictive)
// ============================================

// Historique des prix du DahkaCoin
model DahkaCoinPrice {
  id        String   @id @default(cuid())
  
  price     Decimal  @db.Decimal(10, 4) // Prix en euros
  trend     Int      @default(0)        // Tendance actuelle (-2 à +2)
  
  createdAt DateTime @default(now())

  @@index([createdAt])
}

// Transactions DahkaCoin (pour historique)
model DahkaCoinTx {
  id        String   @id @default(cuid())
  
  userId    String
  type      String   // "buy" ou "sell"
  
  dcAmount  Decimal  @db.Decimal(10, 4) // Quantité de DC
  euroAmount Decimal @db.Decimal(10, 2) // Montant en euros
  price     Decimal  @db.Decimal(10, 4) // Prix au moment de la transaction
  
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
}
